## ❓DI 와 IoC 에 대해서 설명해보세요. 
- **IoC**는 객체를 생성하고 생명주기를 제어하는 권한을 개발자가 아닌 외부 컨테이너가 갖는 것입니다.
- **DI**는 IoC의 구현 방식으로 필요한 객체를 직접 생성하는 것이 아니라 외부에서 주입받는 방식입니다.
- Spring에서는 IoC 컨테이너에 객체들을 생성하면 객체끼리 DI하는 역할을 하고, 컨테이너에 등록한 객체들을 '빈'이라고 함

**➕ 후보 없이 특정 기능을 하는 클래스가 딱 한 개라면, 구체 클래스를 그냥 사용해도 되지 않나요? 
그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?** <br>
이유는 객체 생성 시점, 생명주기, 트랜잭션, AOP, 프록시 등의 스프링 기능이 모두 Bean 단위로 동작하기 때문입니다. 
즉, 단순히 인스턴스를 만드는 것 뿐만 아니라 스프링 컨테이너의 관리 대상이 되어야 앞서 말했던 부가 기능들을 받을 수 있습니다.

**➕ Spring의 Bean 생성 주기에 대해 설명해 주세요.**
1. 스프링 IoC 컨테이너 생성 → 설정 정보(@Configuration, @ComponentScan 등) 로드
2. 스프링 빈 생성 → @Component, @Bean 대상 객체를 new
3. 의존성 주입
4. 초기화 콜백 → @PostConstruct
5. 사용
6. 소멸 콜백

*초기화 콜백: 빈이 준비된 직후 추가 설정이나 리소스 작업 수행 ex) 외부 API 연결, 캐시로드* <br>
*소멸 콜백 : 컨테이너 종료 시 리소스 해제, 연결 종료*

**➕ 프로토타입 빈은 무엇인가요?** <br>
싱글톤 빈과 달리 컨테이너에게 빈을 요청할 때마 매번 새로운 객체를 생성해서 반환해줍니다. 
즉 스프링 컨테이너는 생성과 주입까지만 책임지고, 그 이후 소멸은 개발자가 직접 호출해야합니다.
그래서 매번 독립된 객체가 필요한 사용자 세션과 같은 상황에서 유용합니다. <br>
빈 scope 설정은 @Scope 어노테이션으로 설정하고, 프로토타입 scope로 설정하려면 @Scope(”prototype”)과 같이 문자열로 지정해줍니다.
스프링에서는 빈 생성시 별 다른 설정이 없으면 default로 싱글톤이 적용됩니다.

**➕ Singleton Bean이 Prototype 빈을 주입 받고 있는 상황에서 생길 수 있는 문제는 무엇인가요?** <br>
싱글톤 빈은 애플리케이션 시작 시 한 번만 생성되고 재사용됩니다. 
그런데 프로토타입 빈을 주입 받으면 그 시점에서 한 번만 생성된 프로토타입이 계속 유지됩니다.
즉, 매번 새로운 객체를 기대했는데 실제로는 같은 인스턴스를 재사용하는 문제가 발생하는 것입니다.
이를 해결하려면 필요시점마다 새 프로토타입 빈을 요청하도록 설정해야합니다.

<br>

## ❓Spring DI 에 대해 설명해보세요.
DI (Dependency Injection) <br>
IoC의 구현 방식으로 필요한 객체를 직접 생성하는 것이 아니라 외부에서 주입받는 방식입니다. DI를 통해 객체 간의 결합도를 줄이고, 코드 재사용성을 높일 수 있습니다.  <br>

**➕ 동작과정**
1. 스프링 컨테이너가 실행되면 @component, @Service, @Repository 등을 스캔
2. 각 클래스의 인스턴스를 빈으로 등록
3. 의존 관계를 분석해서 필요한 빈을 찾아 주입

**➕ DI 종류**
- 생성자 주입 : 객체 생성 시 의존성이 확정되며 불변성을 보장할 수 있고, 스프링에 권장되는 방식
- Setter 주입 : 선택적인 의존성에 사용할 수 있지만, 객체 생성 이후에 변경될 수 있다는 단점이 있음
- 필드 주입 : 코드가 간단하지만, 테스트가 어렵고 실무에서는 지양됨

<br>

## ❓Spring IOC 에 대해 설명해보세요.
객체의 생성과 의존관계 설정에 대한 제어권을 개발자가 아닌 스프링 컨테이너가 가지는 것을 의미합니다. 즉, 객체를 직접 new로 생성하거나 연결하지 않고, 스프링이 대신 관리해주는 것입니다.

**➕ IoC 분류**
- DL : 스프링 컨테이너 안에 있는 빈을 개발자가 직접 찾아서 사용하는 방법
- DI : 컨테이너가 알아서 의존성을 주입해주는 방법

**➕ 스프링 컨테이너 종류** <br>
스프링 컨테이너가 관리하는 객체를 빈(Bean)이라고 하고, 이것을 관리하는 역할을 하는 것이 컨테이너입니다.
-  BeanFactory : 빈을 등록, 생성, 조회하는 기본적인 컨테이너 기능을 제공합니다.
-  ApplicationContext : BeanFactory의 기능을 포함하고 이벤트 처리, 메시지 소스, 환경 설정 등 스프링이 제공하는 대부분의 부가 기능을 함께 지원합니다.

<br>

## ❓스프링 빈이라는 게 어떤 역할을 하는지 설명해주세요.
스프링 컨테이너가 관리하는 객체로, 애플리케이션에서 필요한 주요 객체들을 효율적이고 일관되게 사용할 수 있도록 돕는 역할을 합니다.
- 스프링 빈의 생명주기 관리 : 개발자가 직접 new로 객체를 생성하지 않아도 되고, 언제 객체를 생성/초기화/소멸시킬지 스프링이 책임집니다.
- 싱글톤으로 관리 : 애플리케이션 전역에 하나의 객체를 공유해 사용하기에, 객체를 반복해서 생성하지 않아도 되니 성능과 일관성이 향상됩니다.
- 의존성 주입 가능 : 필요한 객체를 스프링이 자동으로 주입해주기 때문에, 객체 간 결합도를 낮출 수 있습니다.

<br>

## ❓Spring Collection 에 대해서 설명해보세요.
Spring Collection은 Spring이 Java 컬렉션 (List, Map, Set, Properties 등)을 빈에 주입할 수 있는 기능을 말합니다. <br>
즉, Spring DI를 통해서 List, Set, Map 같은 컬렉션 객체를 직접 주입하는 것을 말합니다. 
```java
class PizzaStore {
    private final List<String> menus;

    public PizzaStore(List<String> menus) {
        this.menus = menus;
    }
}

@Configuration
public class MenuConfig {

    @Bean
    public List<String> menuList() {
        return List.of("피자", "파스타", "리조또");
    }
}

객체를 직접 new하지 않습니다.
메뉴 리스트를 이미 만들어두고(메뉴를 정해두고)
이 리스트(List<String>)를 Spring 빈으로 등록한 다음
PizzaStore 객체를 만들 때 항상 이 빈을 넣어서 생성해줍니다.
```

<br>
 
## ❓Tomcat이 정확히 어떤 역할을 하는 도구인가요?
Tomcat은 클라이언트의 HTTP 요청을 받아, 이를 서블릿 또는 스프링 MVC 컨트롤러로 전달하고 실행한 뒤, 그 결과를 HTTP 응답으로 반환하는 역할을 하는 도구입니다. 즉, Tomcat은
- HTTP 통신을 처리하고
- 자바 웹 애플리케이션이 실행될 수 있는 환경을 제공하며
- 서블릿의 생성, 실행, 소멸 같은 생명주기를 관리하는 서블릿 컨테이너입니다.
이러한 역할을 통해 Tomcat은 자바 기반 웹 애플리케이션을 실행하는 경량 WAS로 사용됩니다.
  
**➕ 혹시 Netty에 대해 들어보셨나요? 왜 이런 것을 사용할까요?** <br>
Netty는 비동기 이벤트 기반의 고성능 네트워크 서버 프레임워크로, TCP/UDP, WebSocket 등 다양한 프로토콜을 효율적으로 처리할 수 있습니다.<br>
Tomcat은 요청당 스레드 1개를 사용하는 방식이기 때문에 동시 접속자가 많아지면 스레드 수가 급격히 늘어나고 컨텍스트 스위칭 비용이 증가합니다. 반면 Netty는 이벤트 루프(Event Loop) 기반으로 적은 수의 스레드로도 수천~수만 개의 연결을 처리할 수 있기 때문에 실시간 채팅 서버, WebSocket, IoT 서버, 게임 서버처럼 ‘많은 연결을 유지해야 하는 서비스’에 적합합니다. 예를 들어, 손님이 100명이라면 톰캣은 알바생이 100명 필요하고 / 네티는 알바생 5명이 돌아다니며 모두 처리하는 것입니다. <br>
스프링에서도 일반 Spring MVC는 Tomcat 기반이지만, Spring WebFlux나 gRPC 통신처럼 비동기/논블로킹 방식의 서버를 구성할 때는 Netty가 활용됩니다. <br>
*이벤트 루프는 이벤트가 들어오면 큐에 쌓아두고 처리 가능한 순간에 스레드가 하나씩 꺼내서 처리하는 구조입니다.*


