## ❓JVM의 구조에 대해 설명해보세요.
<img width="400" height="255" alt="image" src="https://github.com/user-attachments/assets/9d37f4e7-4f91-4ad7-bf46-543a40ba42e9" />

- **Class Loader** : .class파일(바이트코드)를 JVM 메모리로 적재합니다.
- **Execution Engine** : 바이트코드를 기계어로 변환 후 실행합니다.
- **Runtime Data Areas** : 프로그램 실행 시 사용하는 메모리 공간입니다.
   - Stack : 스레드마다 하나씩 생성, 메서드 호출
   - PC Register : 현재 실행 중인 명령 주소 저장
   - Native Method Stack : 네이티브 코드(C/C++) 실행 시 사용
   - Heap : new로 생성된 객체와 배열, 모든 스레드 공유, GC 대상
   - Method Area : 모든 스레드 공유, 클래스 정보, static 변수, 상수 저장
</br>

## ❓JDK와 JRE, JVM의 차이에 대해 설명해보세요.
<img width="337" height="159" alt="image" src="https://github.com/user-attachments/assets/dfe1c398-edfa-4d9e-999e-a15e0b2689dd" />

- **JDK** : 자바 통합 개발 환경 (JRE, JVM 모두 포함)
- **JRE** : 자바 실행 환경 (JVM + 실행에 필요한 라이브러리와 파일 포함)
- **JVM** : 자바 바이트코드를 OS에 맞게 기계어로 해석해주는 가상머신

**➕ JVM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.** </br>
장점은 플랫폼 독립성입니다. 자바 프로그램은 한 번 작성하면 JVM만 설치되어 있다면 어떤 운영체제에서도 실행할 수 있는 Write Once, Run Anywhere 특징을 가집니다.
또한 가비지 컬렉션을 통해 메모리 영역을 자동으로 관리합니다.
단점은 JVM 위에서 코드가 실행되기 때문에 OS에 맞춘 네이티브 프로그램보다 실행 속도가 늘릴 수 있고
다중 상속이나 타입에 엄격하고 제약이 많습니다.

**➕ JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?** </br>
프로세스는 OS로부터 자원을 할당받는 독립적인 실행 단위입니다. 
JVM은 하나의 프로세스 내에서 여러개의 스레드를 생성하여 자바 프로그램을 실행하기 때문에 부모-자식 프로세스 관계가 아닙니다.

*OS 하나당 JVM 여러개 띄울 수 있음 / JVM = 프로세스 / 하나의 프로세스 JVM 내부에서 여러 스레드 실행*

</br>

## ❓컴파일 과정을 말해보세요.
1. 자바 프로그램이 실행되면 JVM은 OS에서 프로그램에 필요한 메모리를 할당받습니다.
2. 자바 컴파일러가 자바 소스코드를 바이트코드(.class)로 변환시키고, 클래스 로더는 클래스 파일들을 JVM 내부로 로딩합니다.
3. 로딩된 class파일들은 실행엔진이 기계어로 바꾸어 해석하고, 해석된 바이트 코드는 메모리상에 배치되어 실제로 수행하게 됩니다.
4. 이런 실행 과정 중에서 쓰레드 동기화나 GC같은 작업들이 수행됩니다.

</br>

## ❓GC (Garbage Collection) 에 대해서 설명해보세요.
자바 메모리 관리 방법 중 하나로 JVM의 Heap영역에서 동적으로 할당했던 메모리 중 
필요없게 된 메모리 객체를 모아 주기적으로 제거하는 프로세스를 말합니다.
- **stop the world** -> JVM 애플리케이션을 멈추고, GC를 실행하는 스레드를 제외한 모든 스레드 작업을 중단 후
- **mark and sweep** -> 사용하지 않는 메모리를 제거하고
- 작업이 재개됩니다.
  
**➕ Minor GC와 Major GC** </br>
먼저 객체는 기본적으로 Young영역에 생성되는데, 이 영역은 Eden과 Servivor로 나뉘어져 있습니다.
Eden이 가득 차면 **Minor GC**가 발생해 사용하지 않는 객체를 제거하고 남은 객체만 Survivor로 옮겨집니다.
이렇게 여러번 Minor GC를 거쳐 살아남은 객체는 Old영역으로 옮겨지고, 장기간 사용되는 객체들이 쌓이게 됩니다. 
Old영역이 가득차면 **Major GC**가 발생합니다. 
Major GC는 전체 Old영역을 검사하고 압축까지 수행하기 때문에 시간이 오래 걸리고 Stop-the-word 시간이 길어져 성능에 영향을 줄 수 있습니다. 
그래서 Minor GC는 자주 일어나지만 가볍고, Major GC는 드물지만 무겁다는 차이가 있습니다.

</br>

## ❓JAVA의 Garbage Collector는 어떻게 동작하나요?
사용하지 않는 객체를 자동으로 메모리에서 해제합니다. 즉, 실행 중 살아있는 객체를 표시하고 mark, 스레드에서 참조할 수 없는 쓰레기 객체를 메모리에서 sweep합니다.

**➕ finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?** </br>
finalize()는 가비지 컬렉터가 객체를 제거하기 직전에 자동으로 한번 호출하는 메서드입니다. 이것을 개발자가 수동으로 호출하게 되면 객체가 아직 살아있는데도 리소스를 해제할 수 있고, 나중에 GC가 또 finalize()를 자동 호출해서 중복 실행이 될 문제가 있습니다.

**➕ 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?** </br>
변수를 null로 만들면 더 이상 어떤 객체도 가리키고 있지 않다는 것이기 때문에, 객체는 더 이상 프로그램에서 접근할 수 없게 되고 가비지 컬렉션 대상이 됩니다.

</br>

## ❓GC 옵션
GC 옵션은 어떤 GC 알고리즘을 선택할 것인가 + GC의 세부 동작을 어떤 파라미터로 조정할 것인가 두가지 관점에서 설명할 수 있습니다. 
- JVM은 Serial, Parallel, CMS, G1 GC 같은 여러 GC 알고리즘을 제공하며, 애플리케이션의 처리량 중심인지/응답 지연을 줄이는 것이 중요한지에 따라 선택됩니다.
- -Xms, -Xmx로 힙 크기를 설정하고, -XX:NewRatio로 Young/Old 영역 비율을 조정하며, -Xlog:gc* 같은 GC 로그 옵션을 통해 실제 동작을 분석해 튜닝할 수 있습니다.

</br>

## ❓java의 main 메서드가 static인 이유
자바 애플리케이션은 JVM이 실행될 때, 클래스의 객체를 생성하지 않은 상태에서 main 메서드를 먼저 호출합니다.
만약 main 메서드가 static이 아니라면, 이를 호출하기 위해 먼저 객체를 생성해야 하는데, JVM 입장에서는 객체를 만들기 전에 실행할 진입점이 필요합니다. 그래서 main메서드는 객체 생성 없이 호출할 수 있게 static으로 선언되어 있습니다.

