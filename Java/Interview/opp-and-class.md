## ❓클래스, 객체, 인스턴스의 차이
- 클래스는 객체가 가지는 속성이나 기능을 정의하는 틀이고
- 객체는 아직 메모리에 없더라도 클래스의 타입으로 선언된 것이고
- 인스턴스는 클래스로 인해 만들어져서 실제로 메모리 상에 할당되어 존재하는 상태를 가진 객체를 말합니다.

**➕ 객체(Object)란 무엇인가?** </br>
현실세계의 사물이나 개념을 프로그램 안에서 표현한 것, 속성과 행동을 가진 독립적인 단위

</br>

## ❓OOP의 4가지 특징
OPP(Object-Oriented Programming)는 데이터와 메서드를 하나의 객체로 묶어 관리하는 프로그래밍 방법입니다.
- 추상화 : 불필요한 구현을 숨기고 꼭 필요한 기능만 제공하는 것 -> ex) 추상 메서드
- 캡슐화 : 외부에 노출할 필요가 없는 정보들을 은닉하는 것 -> 필요한 정보만 보여주게끔 설계
- 상속화 : 부모 클래스가 자식 클래스에게 속성을 물려주는 것 -> 코드 재사용, 중복 코드 제거
- 다형화 : 같은 인터페이스나 부모 클래스를 공유하는 객체들이 서로 다른 방식으로 동작하는 것 -> ex) 오버라이딩
  
**➕ 장점과 단점** </br>
객체 중심으로 프로그래밍 하기 때문에 사람의 관점에서 프로그램을 이해하고 파악하기 쉽습니다. </br>
강한 응집력과 약한 결합력을 가집니다. 즉, 관계는 있지만 없어도 대체해서 동작시킬 수 있는 유연함이 있습니다. </br>
재사용성과 확장성이 높습니다. 하지만 설계에 많은 시간을 투자해야한다는 단점도 존재합니다.

**➕ 캡슐화와 은닉화의 차이는 무엇인가?** </br>
캡슐화는 객체 지향 프로그래밍에서 데이터랑 메서드를 묶어 하나의 객체로 만드는 것이고, </br>
은닉화는 그 객체 내부의 데이터나 메서드에 대해 외부에서 접근하지 못하도록 접근 제어자로 제한하는 것입니다. </br>
즉, 은닉화는 캡슐화를 이루기 위한 수단입니다.


</br>

## ❓OOP의 5대 원칙
- **SRP** (Single Responsibility Principle) 단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 합니다.
- **OCP** (Open Closed Principle) 개방 폐쇄 원칙 : 확장에는 열려있으나 변경에는 닫혀있어야 합니다. 즉, 새로운 기능이 추가될 때 기존 코드를 수정하지 않고 새로운 클래스를 추가하는 방식으로 확장할 수 있어야 합니다. 
- **LSP** (Liskov Substitution Principle) 리스코프 치환 원칙 : 하위 클래스는 상위 클래스를 대체할 수 있어야합니다. 즉, 상위 클래스 타입으로 객체를 선언해 하위 클래스의 인스턴스를 받으면 업캐스팅된 상태에서 부모 메서드를 사용해도 동작이 의도대로 흘러가야합니다. 예를 들어, Collection 타입 객체 자료형을 LinkedList에서 HashSet으로 바꾸어도 add()메서드는 원래 의도대로 동작하는 것입니다.
- **ISP** (Interface segregation principle) 인터페이스 분리 원칙 : 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다는 것입니다. 즉, 각각 사용에 맞게끔 인터페이스를 잘 분리해야합니다.
- **DIP** (Dependency inversion principle) 의존관계 역전 원칙 : 추상화에 의존해야하지 구체화에 의존하면 안된다는 것입니다. 즉, 구현 클래스에 의존하지 않고 인터페이스에 의존하라는 것 = 클래스 간의 결합도를 낮추라는 것입니다.

</br>

## ❓오버라이딩과 오버로딩은 무엇인지 설명해보세요.
오버라이딩(Overriding)은 상위 클래스에 있는 메소드를 하위 클래스에서 재정의하는 것이고, </br>
오버로딩(Overloading)은 매개변수의 개수나 타입을 다르게 하여 같은 이름의 메소드를 여러개 정의하는 것을 말합니다.

</br>

## ❓interface와 abstract class차이
- 추상 클래스는 클래스 안에 추상 메서드가 하나 이상 포함되거나 abstract로 정의된 것입니다. 공통 상태와 로직을 일부 구현해두고, 필요한 부분만 하위 클래스가 완성하도록 합니다.
- 인터페이스는 모든 메서드가 추상 메서드로만 이루어져 있는 것을 말합니다. 그 인터페이스를 구현하는 모든 클래스에서 모든 추상 메서드 구현을 강제합니다.
- 추상 클래스는 다중 상속이 불가능하지만, 인터페이스는 다중 상속이 가능합니다.

**➕ 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?** </br>
클래스는 상태와 구현이 같이 있어서 다중 상속을 하면 다이아몬드 문제가 발생합니다. </br>
하지만 인터페이스는 실제 구현이 되어있지 않고 정의만 하고 있기 때문에, 다이아몬드 문제처럼 메소드가 겹치더라도 최종 구현은 클래스에서 이루어지기에 다중 상속이 가능합니다. 

</br>

## ❓Enum이란?
Enum은 관련된 상수들을 하나의 타입으로 묶는 열거형입니다. 예를 들어, 요일을 숫자 1~7로 관리하면 가독성이 떨어지고 실수가 발생하기 쉬운데, DayOfWeek.MONDAY처럼 Enum으로 관리하면 코드의 의미가 명확해지고 잘못된 값이 들어왔을 때 컴파일 단계에서 확인할 수 있습니다. 또한 자바 Enum은 단순히 상수들의 모음이 아니라 메서드나 필드도 가질 수 있어서 객체처럼 활용할 수 있습니다.

**➕ Enum은 상속할 수 있을까?** </br>
Java의 enum은 이미 java.lang.Enum 클래스를 상속하고 있고 final이기 때문에 다른 클래스를 상속할 수 없습니다. 대신 인터페이스 구현을 통해 공통 동작을 정의할 수 있습니다.

**➕ static final과 차이는?** </br>
static final 상수는 단순히 값만 정의된 상수이지만, Enum은 하나의 타입으로 관리되는 상수들의 집합입니다. 그래서 Enum으로 관리하면 허용 가능한 값의 범위를 컴파일 타임에 제한할 수 있어 타입 안전성을 보장할 수 있습니다.

</br>

## ❓non-static 멤버와 static 멤버의 차이
static 멤버는 클래스에 속하는 멤버로, 해당 클래스가 처음 사용될 때 JVM에 의해 로딩되며 이 시점에 초기화되고, JVM이 종료될 때까지 메모리에 유지됩니다. 또한 클래스의 인스턴스를 생성하지 않고도 사용할 수 있으며, 그 클래스의 모든 인스턴스가 공유하는 값입니다. </br>
non-static 멤버는 객체에 속하는 멤버로, 객체가 생성될 때 초기화되며 객체가 사라질 때까지 메모리에 남아있습니다. 또한 클래스의 인스턴스를 생성해야 사용이 가능하고, 객체마다 서로 다른 값을 가질 수 있습니다.

</br>

## ❓java의 접근 제어자의 종류
접근제어자는 객체지향에서 정보 은닉을 위해 외부에서 클래스에 접근하지 못하도록 사용합니다.
- public : 같은 패키지, 다른 패키지 어디서나 접근이 가능한 가장 개방적인 접근제어자 입니다.
- protected : 같은 패키지 내에서는 접근이 허용되지만 다른 패키지에서는 자식 클래스까지만 접근을 허용합니다.
- default : 같은 패키지 내에서만 접근이 가능하고 다른 패키지에서는 불가능합니다.
- private : 클래스 내부가 아닌 다른 모든 클래스에서 접근이 불가능합니다.


